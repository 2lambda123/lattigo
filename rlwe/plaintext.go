package rlwe

import (
	"bufio"
	"fmt"
	"io"

	"github.com/tuneinsight/lattigo/v4/ring"
	"github.com/tuneinsight/lattigo/v4/utils/buffer"
)

// Plaintext is a common base type for RLWE plaintexts.
type Plaintext struct {
	MetaData
	Value *ring.Poly
}

// NewPlaintext creates a new Plaintext at level `level` from the parameters.
func NewPlaintext(params Parameters, level int) (pt *Plaintext) {
	return &Plaintext{Value: ring.NewPoly(params.N(), level), MetaData: MetaData{Scale: params.defaultScale, IsNTT: params.defaultNTTFlag}}
}

// NewPlaintextAtLevelFromPoly constructs a new Plaintext at a specific level
// where the message is set to the passed poly. No checks are performed on poly and
// the returned Plaintext will share its backing array of coefficients.
// Returned plaintext's MetaData is empty.
func NewPlaintextAtLevelFromPoly(level int, poly *ring.Poly) (pt *Plaintext) {
	if len(poly.Coeffs) < level+1 {
		panic("cannot NewPlaintextAtLevelFromPoly: provided ring.Poly level is too small")
	}
	v0 := new(ring.Poly)
	v0.Coeffs = poly.Coeffs[:level+1]
	v0.Buff = poly.Buff[:poly.N()*(level+1)]
	return &Plaintext{Value: v0}
}

// Degree returns the degree of the target Plaintext.
func (pt *Plaintext) Degree() int {
	return 0
}

// Level returns the level of the target Plaintext.
func (pt *Plaintext) Level() int {
	return len(pt.Value.Coeffs) - 1
}

// GetScale gets the scale of the target Plaintext.
func (pt *Plaintext) GetScale() Scale {
	return pt.Scale
}

// SetScale sets the scale of the target Plaintext.
func (pt *Plaintext) SetScale(scale Scale) {
	pt.Scale = scale
}

// El returns the plaintext as a new `Element` for which the value points
// to the receiver `Value` field.
func (pt *Plaintext) El() *Ciphertext {
	return &Ciphertext{Value: []*ring.Poly{pt.Value}, MetaData: pt.MetaData}
}

// Copy copies the `other` plaintext value into the receiver plaintext.
func (pt *Plaintext) Copy(other *Plaintext) {
	if other != nil && other.Value != nil {
		pt.Value.Copy(other.Value)
		pt.MetaData = other.MetaData
	}
}

// MarshalBinarySize returns the size in bytes that the object once marshalled into a binary form.
func (pt *Plaintext) MarshalBinarySize() (dataLen int) {
	return pt.MetaData.MarshalBinarySize() + pt.Value.MarshalBinarySize()
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (pt *Plaintext) MarshalBinary() (data []byte, err error) {
	data = make([]byte, pt.MarshalBinarySize())
	_, err = pt.Read(data)
	return
}

// WriteTo writes the object on an io.Writer.
// To ensure optimal efficiency and minimal allocations, the user is encouraged
// to provide a struct implementing the interface buffer.Writer, which defines
// a subset of the method of the bufio.Writer.
// If w is not compliant to the buffer.Writer interface, it will be wrapped in
// a new bufio.Writer.
// For additional information, see lattigo/utils/buffer/writer.go.
func (pt *Plaintext) WriteTo(w io.Writer) (n int64, err error) {
	switch w := w.(type) {
	case buffer.Writer:

		if n, err = pt.MetaData.WriteTo(w); err != nil {
			return n, err
		}

		var inc int64
		if inc, err = pt.Value.WriteTo(w); err != nil {
			return n + inc, err
		}

		n += inc

		return
	default:
		return pt.WriteTo(bufio.NewWriter(w))
	}
}

// ReadFrom reads on the object from an io.Writer.
// To ensure optimal efficiency and minimal allocations, the user is encouraged
// to provide a struct implementing the interface buffer.Reader, which defines
// a subset of the method of the bufio.Reader.
// If r is not compliant to the buffer.Reader interface, it will be wrapped in
// a new bufio.Reader.
// For additional information, see lattigo/utils/buffer/reader.go.
func (pt *Plaintext) ReadFrom(r io.Reader) (n int64, err error) {
	switch r := r.(type) {
	case buffer.Reader:

		if n, err = pt.MetaData.ReadFrom(r); err != nil {
			return n, err
		}

		if pt.Value == nil {
			pt.Value = new(ring.Poly)
		}

		var inc int64
		if inc, err = pt.Value.ReadFrom(r); err != nil {
			return int64(n) + inc, err
		}

		n += inc

		return

	default:
		return pt.ReadFrom(bufio.NewReader(r))
	}
}

// Read encodes the object into a binary form on a preallocated slice of bytes
// and returns the number of bytes written.
func (pt *Plaintext) Read(data []byte) (ptr int, err error) {

	if len(data) < pt.MarshalBinarySize() {
		return 0, fmt.Errorf("cannot write: len(data) is too small")
	}

	if ptr, err = pt.MetaData.Read(data); err != nil {
		return
	}

	if pt.Value == nil {
		pt.Value = new(ring.Poly)
	}

	var inc int
	if inc, err = pt.Value.Read(data[ptr:]); err != nil {
		return
	}

	ptr += inc

	return
}

// UnmarshalBinary decodes a slice of bytes generated by MarshalBinary
// or Read on the object.
func (pt *Plaintext) UnmarshalBinary(data []byte) (err error) {
	_, err = pt.Write(data)
	return
}

// Write decodes a slice of bytes generated by MarshalBinary or
// Read on the object and returns the number of bytes read.
func (pt *Plaintext) Write(data []byte) (ptr int, err error) {

	if ptr, err = pt.MetaData.Write(data); err != nil {
		return
	}

	if pt.Value == nil {
		pt.Value = new(ring.Poly)
	}

	var inc int
	if inc, err = pt.Value.Write(data[ptr:]); err != nil {
		return
	}

	ptr += inc

	return
}
