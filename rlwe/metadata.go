package rlwe

import (
	"encoding/json"
	"fmt"
	"io"
	"math/big"

	"github.com/google/go-cmp/cmp"
)

type EncodingDomain int

const (
	FrequencyDomain = EncodingDomain(0)
	TimeDomain      = EncodingDomain(1)
)

// MetaData is a struct storing metadata.
type MetaData struct {
	PlaintextScale         Scale
	EncodingDomain         EncodingDomain
	PlaintextLogDimensions [2]int
	IsNTT                  bool
	IsMontgomery           bool
}

// Equal returns true if two MetaData structs are identical.
func (m *MetaData) Equal(other *MetaData) (res bool) {
	res = cmp.Equal(&m.PlaintextScale, &other.PlaintextScale)
	res = res && m.EncodingDomain == other.EncodingDomain
	res = res && m.PlaintextLogDimensions == other.PlaintextLogDimensions
	res = res && m.IsNTT == other.IsNTT
	res = res && m.IsMontgomery == other.IsMontgomery
	return
}

// PlaintextDimensions returns the dimensions of the plaintext matrix.
func (m MetaData) PlaintextDimensions() [2]int {
	return [2]int{1 << m.PlaintextLogDimensions[0], 1 << m.PlaintextLogDimensions[1]}
}

// PlaintextSlots returns the total number of entries in the plaintext matrix.
func (m MetaData) PlaintextSlots() int {
	return 1 << m.PlaintextLogSlots()
}

// PlaintextLogSlots returns the log of the total number of entries in the plaintext matrix.
func (m MetaData) PlaintextLogSlots() int {
	return m.PlaintextLogDimensions[0] + m.PlaintextLogDimensions[1]
}

// BinarySize returns the size in bytes that the object once marshalled into a binary form.
func (m MetaData) BinarySize() int {
	return 121 + m.PlaintextScale.BinarySize()
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
func (m *MetaData) WriteTo(w io.Writer) (int64, error) {
	if p, err := m.MarshalBinary(); err != nil {
		return 0, err
	} else {
		if n, err := w.Write(p); err != nil {
			return int64(n), err
		} else {
			return int64(n), nil
		}
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
func (m *MetaData) ReadFrom(r io.Reader) (int64, error) {
	p := make([]byte, m.BinarySize())
	if n, err := r.Read(p); err != nil {
		return int64(n), err
	} else {
		return int64(n), m.UnmarshalBinary(p)
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (m MetaData) MarshalBinary() (p []byte, err error) {

	var IsNTT, IsMontgomery uint8

	if m.IsNTT {
		IsNTT = 1
	}

	if m.IsMontgomery {
		IsMontgomery = 1
	}

	aux := &struct {
		PlaintextScale         Scale
		EncodingDomain         string
		PlaintextLogDimensions [2]string
		IsNTT                  string
		IsMontgomery           string
	}{
		PlaintextScale:         m.PlaintextScale,
		EncodingDomain:         fmt.Sprintf("0x%02x", uint8(m.EncodingDomain)),
		PlaintextLogDimensions: [2]string{fmt.Sprintf("0x%02x", uint8(m.PlaintextLogDimensions[0])), fmt.Sprintf("0x%02x", uint8(m.PlaintextLogDimensions[1]))},
		IsNTT:                  fmt.Sprintf("0x%02x", IsNTT),
		IsMontgomery:           fmt.Sprintf("0x%02x", IsMontgomery),
	}

	return json.Marshal(aux)

}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (m *MetaData) UnmarshalBinary(p []byte) (err error) {

	aux := &struct {
		PlaintextScale         Scale
		EncodingDomain         string
		PlaintextLogDimensions [2]string
		IsNTT                  string
		IsMontgomery           string
	}{}

	if err = json.Unmarshal(p, aux); err != nil {
		return
	}

	hexconv := func(x string) (uint64, error) {
		yBig, err := new(big.Int).SetString(x, 0)
		if !err {
			return 0, fmt.Errorf("hexconv: unsuccessful SetString")
		}
		return yBig.Uint64(), nil
	}

	m.PlaintextScale = aux.PlaintextScale

	ecdDom, err := hexconv(aux.EncodingDomain)

	if err != nil {
		return err
	}

	m.EncodingDomain = EncodingDomain(ecdDom)

	logRows, err := hexconv(aux.PlaintextLogDimensions[0])

	if err != nil {
		return err
	}

	logCols, err := hexconv(aux.PlaintextLogDimensions[1])

	if err != nil {
		return err
	}

	m.PlaintextLogDimensions = [2]int{int(int8(logRows)), int(int8(logCols))}

	if y, err := hexconv(aux.IsNTT); err != nil {
		return err
	} else if y == 1 {
		m.IsNTT = true
	}

	if y, err := hexconv(aux.IsMontgomery); err != nil {
		return err
	} else if y == 1 {
		m.IsMontgomery = true
	}

	return
}
