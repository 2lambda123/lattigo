package rlwe

import (
	"fmt"
	"io"

	"github.com/google/go-cmp/cmp"
)

type EncodingDomain int

const (
	FrequencyDomain = EncodingDomain(0)
	TimeDomain      = EncodingDomain(1)
)

// MetaData is a struct storing metadata.
type MetaData struct {
	PlaintextScale         Scale
	EncodingDomain         EncodingDomain
	PlaintextLogDimensions [2]int
	IsNTT                  bool
	IsMontgomery           bool
}

// Equal returns true if two MetaData structs are identical.
func (m *MetaData) Equal(other *MetaData) (res bool) {
	res = cmp.Equal(&m.PlaintextScale, &other.PlaintextScale)
	res = res && m.EncodingDomain == other.EncodingDomain
	res = res && m.PlaintextLogDimensions == other.PlaintextLogDimensions
	res = res && m.IsNTT == other.IsNTT
	res = res && m.IsMontgomery == other.IsMontgomery
	return
}

// PlaintextDimensions returns the dimensions of the plaintext matrix.
func (m MetaData) PlaintextDimensions() [2]int {
	return [2]int{1 << m.PlaintextLogDimensions[0], 1 << m.PlaintextLogDimensions[1]}
}

// PlaintextSlots returns the total number of entries in the plaintext matrix.
func (m MetaData) PlaintextSlots() int {
	return 1 << m.PlaintextLogSlots()
}

// PlaintextLogSlots returns the log of the total number of entries in the plaintext matrix.
func (m MetaData) PlaintextLogSlots() int {
	return m.PlaintextLogDimensions[0] + m.PlaintextLogDimensions[1]
}

// BinarySize returns the size in bytes that the object once marshalled into a binary form.
func (m MetaData) BinarySize() int {
	return 5 + m.PlaintextScale.BinarySize()
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
func (m *MetaData) WriteTo(w io.Writer) (int64, error) {
	if p, err := m.MarshalBinary(); err != nil {
		return 0, err
	} else {
		if n, err := w.Write(p); err != nil {
			return int64(n), err
		} else {
			return int64(n), nil
		}
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
func (m *MetaData) ReadFrom(r io.Reader) (int64, error) {
	p := make([]byte, m.BinarySize())
	if n, err := r.Read(p); err != nil {
		return int64(n), err
	} else {
		_, err = m.Decode(p)
		return int64(n), err
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (m MetaData) MarshalBinary() (p []byte, err error) {
	p = make([]byte, m.BinarySize())
	_, err = m.Encode(p)
	return
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (m *MetaData) UnmarshalBinary(p []byte) (err error) {
	_, err = m.Decode(p)
	return
}

// Encode encodes the object into a binary form on a preallocated slice of bytes
// and returns the number of bytes written.
func (m MetaData) Encode(p []byte) (n int, err error) {

	if len(p) < m.BinarySize() {
		return 0, fmt.Errorf("cannot Encode: len(p) is too small")
	}

	if n, err = m.PlaintextScale.Encode(p[n:]); err != nil {
		return 0, err
	}

	p[n] = uint8(m.EncodingDomain)
	n++

	p[n] = uint8(m.PlaintextLogDimensions[0])
	n++

	p[n] = uint8(m.PlaintextLogDimensions[1])
	n++

	if m.IsNTT {
		p[n] = 1
	}

	n++

	if m.IsMontgomery {
		p[n] = 1
	}

	n++

	return
}

// Decode decodes a slice of bytes generated by Encode
// on the object and returns the number of bytes read.
func (m *MetaData) Decode(p []byte) (n int, err error) {

	if len(p) < m.BinarySize() {
		return 0, fmt.Errorf("canoot Decode: len(p) is too small")
	}

	if n, err = m.PlaintextScale.Decode(p[n:]); err != nil {
		return
	}

	m.EncodingDomain = EncodingDomain(p[n])
	n++

	m.PlaintextLogDimensions[0] = int(int8(p[n]))
	n++

	m.PlaintextLogDimensions[1] = int(int8(p[n]))
	n++

	m.IsNTT = p[n] == 1
	n++

	m.IsMontgomery = p[n] == 1
	n++

	return
}
