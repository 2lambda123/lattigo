package drlwe

import (
	"io"

	"github.com/tuneinsight/lattigo/v4/ring"
	"github.com/tuneinsight/lattigo/v4/rlwe"
	"github.com/tuneinsight/lattigo/v4/rlwe/ringqp"
	"github.com/tuneinsight/lattigo/v4/utils/sampling"
)

// PublicKeyGenProtocol is the structure storing the parameters and and precomputations for
// the collective encryption key generation protocol.
type PublicKeyGenProtocol struct {
	params           rlwe.Parameters
	gaussianSamplerQ ring.Sampler
}

// PublicKeyGenShare is a struct storing the PublicKeyGen protocol's share.
type PublicKeyGenShare struct {
	Value ringqp.Poly
}

// PublicKeyGenCRP is a type for common reference polynomials in the PublicKeyGen protocol.
type PublicKeyGenCRP struct {
	Value ringqp.Poly
}

// ShallowCopy creates a shallow copy of PublicKeyGenProtocol in which all the read-only data-structures are
// shared with the receiver and the temporary buffers are reallocated. The receiver and the returned
// PublicKeyGenProtocol can be used concurrently.
func (ckg *PublicKeyGenProtocol) ShallowCopy() *PublicKeyGenProtocol {
	prng, err := sampling.NewPRNG()
	if err != nil {
		panic(err)
	}

	return &PublicKeyGenProtocol{ckg.params, ring.NewSampler(prng, ckg.params.RingQ(), ckg.params.Xe(), false)}
}

// BinarySize returns the size in bytes of the object
// when encoded using Encode.
func (share *PublicKeyGenShare) BinarySize() int {
	return share.Value.BinarySize()
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (share *PublicKeyGenShare) MarshalBinary() (p []byte, err error) {
	return share.Value.MarshalBinary()
}

// Encode encodes the object into a binary form on a preallocated slice of bytes
// and returns the number of bytes written.
func (share *PublicKeyGenShare) Encode(p []byte) (ptr int, err error) {
	return share.Value.Encode(p)
}

// WriteTo writes the object on an io.Writer.
// To ensure optimal efficiency and minimal allocations, the user is encouraged
// to provide a struct implementing the interface buffer.Writer, which defines
// a subset of the method of the bufio.Writer.
// If w is not compliant to the buffer.Writer interface, it will be wrapped in
// a new bufio.Writer.
// For additional information, see lattigo/utils/buffer/writer.go.
func (share *PublicKeyGenShare) WriteTo(w io.Writer) (n int64, err error) {
	return share.Value.WriteTo(w)
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (share *PublicKeyGenShare) UnmarshalBinary(p []byte) (err error) {
	return share.Value.UnmarshalBinary(p)
}

// Decode decodes a slice of bytes generated by Encode
// on the object and returns the number of bytes read.
func (share *PublicKeyGenShare) Decode(p []byte) (n int, err error) {
	return share.Value.Decode(p)
}

// ReadFrom reads on the object from an io.Writer.
// To ensure optimal efficiency and minimal allocations, the user is encouraged
// to provide a struct implementing the interface buffer.Reader, which defines
// a subset of the method of the bufio.Reader.
// If r is not compliant to the buffer.Reader interface, it will be wrapped in
// a new bufio.Reader.
// For additional information, see lattigo/utils/buffer/reader.go.
func (share *PublicKeyGenShare) ReadFrom(r io.Reader) (n int64, err error) {
	return share.Value.ReadFrom(r)
}

// NewPublicKeyGenProtocol creates a new PublicKeyGenProtocol instance
func NewPublicKeyGenProtocol(params rlwe.Parameters) *PublicKeyGenProtocol {
	ckg := new(PublicKeyGenProtocol)
	ckg.params = params
	var err error
	prng, err := sampling.NewPRNG()
	if err != nil {
		panic(err)
	}
	ckg.gaussianSamplerQ = ring.NewSampler(prng, params.RingQ(), params.Xe(), false)
	return ckg
}

// AllocateShare allocates the share of the PublicKeyGen protocol.
func (ckg *PublicKeyGenProtocol) AllocateShare() *PublicKeyGenShare {
	return &PublicKeyGenShare{*ckg.params.RingQP().NewPoly()}
}

// SampleCRP samples a common random polynomial to be used in the PublicKeyGen protocol from the provided
// common reference string.
func (ckg *PublicKeyGenProtocol) SampleCRP(crs CRS) PublicKeyGenCRP {
	crp := ckg.params.RingQP().NewPoly()
	ringqp.NewUniformSampler(crs, *ckg.params.RingQP()).Read(crp)
	return PublicKeyGenCRP{*crp}
}

// GenShare generates the party's public key share from its secret key as:
//
// crp*s_i + e_i
//
// for the receiver protocol. Has no effect is the share was already generated.
func (ckg *PublicKeyGenProtocol) GenShare(sk *rlwe.SecretKey, crp PublicKeyGenCRP, shareOut *PublicKeyGenShare) {
	ringQP := ckg.params.RingQP()

	ckg.gaussianSamplerQ.Read(shareOut.Value.Q)

	if ringQP.RingP != nil {
		ringQP.ExtendBasisSmallNormAndCenter(shareOut.Value.Q, ckg.params.MaxLevelP(), nil, shareOut.Value.P)
	}

	ringQP.NTT(&shareOut.Value, &shareOut.Value)
	ringQP.MForm(&shareOut.Value, &shareOut.Value)

	ringQP.MulCoeffsMontgomeryThenSub(&sk.Value, &crp.Value, &shareOut.Value)
}

// AggregateShares aggregates a new share to the aggregate key
func (ckg *PublicKeyGenProtocol) AggregateShares(share1, share2, shareOut *PublicKeyGenShare) {
	ckg.params.RingQP().Add(&share1.Value, &share2.Value, &shareOut.Value)
}

// GenPublicKey return the current aggregation of the received shares as a bfv.PublicKey.
func (ckg *PublicKeyGenProtocol) GenPublicKey(roundShare *PublicKeyGenShare, crp PublicKeyGenCRP, pubkey *rlwe.PublicKey) {
	pubkey.Value[0].Copy(&roundShare.Value)
	pubkey.Value[1].Copy(&crp.Value)
}
